{"id":"Promise_all_errors","createTime":"2018-01-19T03:11:34.791Z","html":"<h3>Promise All Catch All error</h3>\n<h4>1.  Promise.all 在有一个promise reject的时候就会掉入catch方法，此时catch的error只是reject的promise的error</h4>\n<h4>2. 实现了一个catch所有error的方法，原理就是原来的promise array会返回一个新的resolving中的promise array</h4>\n<h4>3. 新的promise array每一项都会resolve，然后用Promise.all去处理这个新的promise array</h4>\n<h4>4. 实现如下</h4>\n<pre><code class=\"language-ecmascript\">function wrapperPromiseAll(promises){\n  let resolvingPromises = promises.map(promise=&gt;{\n    return new Promise(resolve =&gt; {\n      let payLoad = {};\n      promise.then(result=&gt;{\n        payLoad.success = result;\n      }).catch(err=&gt;{\n        payLoad.error  = err;\n      }).then(()=&gt;{\n        resolve(payLoad);\n      })\n    })\n  });\n  return Promise.all(resolvingPromises)\n    .then(results=&gt;{\n      let errors = [],result = [];\n      results.forEach(payLoad=&gt;{\n        if(payLoad.success){\n          result.push(payLoad.success)\n        }else {\n          errors.push(payLoad.error)\n        }\n      });\n      return new Promise((resolve,reject) =&gt;{\n        ~errors.length &lt; -1 ? reject(errors) : resolve(result);\n      } )\n    })\n}\n</code></pre>\n<h4>5. 测试如下</h4>\n<pre><code class=\"language-ecmascript\">let promise1 = new Promise(((resolve, reject) =&gt; {\n    setTimeout(reject,100,'a')\n}))\n\nlet promise2 = new Promise(((resolve, reject) =&gt; {\n    setTimeout(reject,100,'b')\n}))\n\n// 直接应用Promise.all\nPromise.all([promise1,promise2]).then(console).catch(console)\n\n// Promise {&lt;rejected&gt;: &quot;a&quot;}\n\n\n//使用wrapper\nwrapperPromiseAll([promise1,promise2])\n\n//Promise {&lt;rejected&gt;: Array(2)}\n</code></pre>\n"}